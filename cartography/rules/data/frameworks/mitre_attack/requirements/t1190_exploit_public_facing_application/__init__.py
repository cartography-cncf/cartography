"""
MITRE ATT&CK Framework
Security framework based on MITRE ATT&CK tactics and techniques
"""

from cartography.rules.spec.model import Fact
from cartography.rules.spec.model import Module
from cartography.rules.spec.model import Requirement

# AWS
_aws_ec2_instance_internet_exposed = Fact(
    id="aws_ec2_instance_internet_exposed",
    name="Internet-Exposed EC2 Instances on Common Management Ports",
    description=(
        "EC2 instances exposed to the internet on ports 22, 3389, 3306, 5432, 6379, 9200, 27017"
    ),
    cypher_query="""
    MATCH (a:AWSAccount)-[:RESOURCE]->(ec2:EC2Instance)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:MEMBER_OF_EC2_SECURITY_GROUP]-(rule:IpPermissionInbound)
    MATCH (rule)<-[:MEMBER_OF_IP_RULE]-(ip:IpRange{range:'0.0.0.0/0'})
    WHERE rule.fromport IN [22, 3389, 3306, 5432, 6379, 9200, 27017]
    RETURN a.name AS account, ec2.instanceid AS instance, rule.fromport AS port, sg.groupid AS sg order by account, instance, port, sg
    """,
    cypher_visual_query="""
    MATCH p=(a:AWSAccount)-[:RESOURCE]->(ec2:EC2Instance)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:MEMBER_OF_EC2_SECURITY_GROUP]-(rule:IpPermissionInbound)
    MATCH p2=(rule)<-[:MEMBER_OF_IP_RULE]-(ip:IpRange{range:'0.0.0.0/0'})
    WHERE rule.fromport IN [22, 3389, 3306, 5432, 6379, 9200, 27017]
    RETURN *
    """,
    module=Module.AWS,
)
_aws_s3_public = Fact(
    id="aws_s3_public",
    name="Internet-Accessible S3 Storage Attack Surface",
    description=("AWS S3 buckets accessible from the internet"),
    cypher_query="""
    MATCH (b:S3Bucket)
    WHERE b.anonymous_access = true
    OR (b.anonymous_actions IS NOT NULL AND size(b.anonymous_actions) > 0)
    OR EXISTS {
        MATCH (b)-[:POLICY_STATEMENT]->(stmt:S3PolicyStatement)
        WHERE stmt.effect = 'Allow'
        AND (stmt.principal = '*' OR stmt.principal CONTAINS 'AllUsers')
    }
    RETURN b.name AS bucket,
        b.region AS region,
        b.anonymous_access AS public_access,
        b.anonymous_actions AS public_actions
    """,
    cypher_visual_query="""
    MATCH (b:S3Bucket)
    WHERE b.anonymous_access = true
    OR (b.anonymous_actions IS NOT NULL AND size(b.anonymous_actions) > 0)
    OR EXISTS {
        MATCH (b)-[:POLICY_STATEMENT]->(stmt:S3PolicyStatement)
        WHERE stmt.effect = 'Allow'
        AND (stmt.principal = '*' OR stmt.principal CONTAINS 'AllUsers')
    }
    WITH b
    OPTIONAL MATCH p=(b)-[:POLICY_STATEMENT]->(:S3PolicyStatement)
    RETURN *
    """,
    module=Module.AWS,
)
_aws_rds_public_access = Fact(
    id="aws_rds_public_access",
    name="Internet-Accessible RDS Database Attack Surface",
    description="AWS RDS instances accessible from the internet",
    cypher_query="""
    MATCH (rds:RDSInstance)
    WHERE rds.publicly_accessible = true
    RETURN rds.id AS instance_id,
        rds.engine AS engine,
        rds.db_instance_class AS instance_class,
        rds.endpoint_address AS endpoint,
        rds.endpoint_port AS port,
        rds.region AS region,
        rds.storage_encrypted AS encrypted
    """,
    cypher_visual_query="""
    MATCH p1=(rds:RDSInstance{publicly_accessible: true})
    OPTIONAL MATCH p2=(rds)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)
    OPTIONAL MATCH p3=(rds)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:MEMBER_OF_EC2_SECURITY_GROUP]-(rule:IpPermissionInbound:IpRule)
    OPTIONAL MATCH p4=(rds)-[:MEMBER_OF_EC2_SECURITY_GROUP]->(sg:EC2SecurityGroup)<-[:MEMBER_OF_EC2_SECURITY_GROUP]-(rule:IpPermissionInbound:IpRule)<-[:MEMBER_OF_IP_RULE]-(ip:IpRange)
    RETURN *
    """,
    module=Module.AWS,
)

# AWS Additional Rules
_aws_load_balancer_internet_facing = Fact(
    id="aws_load_balancer_internet_facing",
    name="Internet-Facing Load Balancers",
    description="AWS Elastic Load Balancers with internet-facing scheme that expose backend services to the public internet",
    cypher_query="""
    MATCH (a:AWSAccount)-[:RESOURCE]->(lb:LoadBalancer)
    WHERE lb.exposed_internet = true
    RETURN a.name AS account,
        lb.dnsname AS dns_name,
        lb.scheme AS scheme,
        lb.region AS region
    ORDER BY account, dns_name
    """,
    cypher_visual_query="""
    MATCH p=(a:AWSAccount)-[:RESOURCE]->(lb:LoadBalancer)
    WHERE lb.exposed_internet = true
    OPTIONAL MATCH p2=(lb)-[:ELB_LISTENER]->(listener:ELBListener)
    OPTIONAL MATCH p3=(lb)-[:EXPOSE]->(ec2:EC2Instance)
    RETURN *
    """,
    module=Module.AWS,
)

_aws_load_balancer_v2_internet_facing = Fact(
    id="aws_load_balancer_v2_internet_facing",
    name="Internet-Facing Application/Network Load Balancers",
    description="AWS ALB/NLB load balancers with internet-facing scheme that expose backend services to the public internet",
    cypher_query="""
    MATCH (a:AWSAccount)-[:RESOURCE]->(lb:LoadBalancerV2)
    WHERE lb.exposed_internet = true
    RETURN a.name AS account,
        lb.dnsname AS dns_name,
        lb.type AS type,
        lb.scheme AS scheme,
        lb.region AS region
    ORDER BY account, dns_name
    """,
    cypher_visual_query="""
    MATCH p=(a:AWSAccount)-[:RESOURCE]->(lb:LoadBalancerV2)
    WHERE lb.exposed_internet = true
    OPTIONAL MATCH p2=(lb)-[:ELBV2_LISTENER]->(listener:ELBV2Listener)
    OPTIONAL MATCH p3=(lb)-[:EXPOSE]->(ec2:EC2Instance)
    RETURN *
    """,
    module=Module.AWS,
)

_aws_elasticsearch_public_access = Fact(
    id="aws_elasticsearch_public_access",
    name="Internet-Accessible Elasticsearch Domains",
    description="AWS Elasticsearch domains with policies that make them accessible from the internet",
    cypher_query="""
    MATCH (a:AWSAccount)-[:RESOURCE]->(es:ESDomain)
    WHERE es.exposed_internet = true
    RETURN a.name AS account,
        es.domainname AS domain_name,
        es.elasticsearch_version AS version,
        es.region AS region,
        es.endpoint AS endpoint
    ORDER BY account, domain_name
    """,
    cypher_visual_query="""
    MATCH p=(a:AWSAccount)-[:RESOURCE]->(es:ESDomain)
    WHERE es.exposed_internet = true
    RETURN *
    """,
    module=Module.AWS,
)

_aws_lambda_anonymous_access = Fact(
    id="aws_lambda_anonymous_access",
    name="Lambda Functions with Anonymous Internet Access",
    description="AWS Lambda functions that allow anonymous access or are accessible from the internet",
    cypher_query="""
    MATCH (a:AWSAccount)-[:RESOURCE]->(lambda:AWSLambda)
    WHERE lambda.anonymous_access = true
    OR (lambda.anonymous_actions IS NOT NULL AND size(lambda.anonymous_actions) > 0)
    RETURN a.name AS account,
        lambda.functionname AS function_name,
        lambda.region AS region,
        lambda.anonymous_access AS anonymous_access,
        lambda.anonymous_actions AS anonymous_actions
    ORDER BY account, function_name
    """,
    cypher_visual_query="""
    MATCH p=(a:AWSAccount)-[:RESOURCE]->(lambda:AWSLambda)
    WHERE lambda.anonymous_access = true
    OR (lambda.anonymous_actions IS NOT NULL AND size(lambda.anonymous_actions) > 0)
    RETURN *
    """,
    module=Module.AWS,
)

_aws_api_gateway_anonymous_access = Fact(
    id="aws_api_gateway_anonymous_access",
    name="API Gateway with Anonymous Internet Access",
    description="AWS API Gateway endpoints that allow anonymous access or are accessible from the internet",
    cypher_query="""
    MATCH (a:AWSAccount)-[:RESOURCE]->(api:AWSAPIGateway)
    WHERE api.anonymous_access = true
    OR (api.anonymous_actions IS NOT NULL AND size(api.anonymous_actions) > 0)
    RETURN a.name AS account,
        api.name AS api_name,
        api.id AS api_id,
        api.region AS region,
        api.anonymous_access AS anonymous_access,
        api.anonymous_actions AS anonymous_actions
    ORDER BY account, api_name
    """,
    cypher_visual_query="""
    MATCH p=(a:AWSAccount)-[:RESOURCE]->(api:AWSAPIGateway)
    WHERE api.anonymous_access = true
    OR (api.anonymous_actions IS NOT NULL AND size(api.anonymous_actions) > 0)
    RETURN *
    """,
    module=Module.AWS,
)

_aws_eks_public_endpoint = Fact(
    id="aws_eks_public_endpoint",
    name="EKS Clusters with Public API Endpoints",
    description="AWS EKS clusters with public API server endpoints accessible from the internet",
    cypher_query="""
    MATCH (a:AWSAccount)-[:RESOURCE]->(eks:EKSCluster)
    WHERE eks.exposed_internet = true
    OR eks.endpoint_public_access = true
    RETURN a.name AS account,
        eks.name AS cluster_name,
        eks.region AS region,
        eks.endpoint AS endpoint,
        eks.endpoint_public_access AS public_access
    ORDER BY account, cluster_name
    """,
    cypher_visual_query="""
    MATCH p=(a:AWSAccount)-[:RESOURCE]->(eks:EKSCluster)
    WHERE eks.exposed_internet = true
    OR eks.endpoint_public_access = true
    RETURN *
    """,
    module=Module.AWS,
)

# Azure
_azure_storage_public_blob_access = Fact(
    id="azure_storage_public_blob_access",
    name="Azure Storage Accounts with Public Blob Containers",
    description=(
        "Azure Storage Accounts that have blob containers with public access. "
        "If a storage blob container has public_access set to 'Container' or 'Blob', "
        "it means that the container is publicly accessible."
    ),
    cypher_query="""
    MATCH (sa:AzureStorageAccount)-[:USES]->(bs:AzureStorageBlobService)-[:CONTAINS]->(bc:AzureStorageBlobContainer)
    WHERE bc.publicaccess IN ['Container', 'Blob']
    RETURN sa.name AS storage_account,
        sa.resourcegroup AS resource_group,
        sa.location AS location,
        bc.name AS container_name,
        bc.publicaccess AS public_access
    """,
    cypher_visual_query="""
    MATCH p=(sa:AzureStorageAccount)-[:USES]->(bs:AzureStorageBlobService)-[:CONTAINS]->(bc:AzureStorageBlobContainer)
    WHERE bc.publicaccess IN ['Container', 'Blob']
    RETURN *
    """,
    module=Module.AZURE,
)

_azure_sql_database_public = Fact(
    id="azure_sql_database_public",
    name="Azure SQL Databases on Public Servers",
    description="Azure SQL databases hosted on servers that might be accessible from the internet",
    cypher_query="""
    MATCH (server:AzureSQLServer)-[:RESOURCE]->(db:AzureSQLDatabase)
    WHERE server.public_network_access = 'Enabled'
    OR EXISTS {
        MATCH (server)-[:FIREWALL_RULE]->(rule:AzureFirewallRule)
        WHERE rule.start_ip_address = '0.0.0.0' AND rule.end_ip_address = '255.255.255.255'
    }
    RETURN server.name AS server_name,
        server.resourcegroup AS resource_group,
        server.location AS location,
        db.name AS database_name,
        server.public_network_access AS public_access
    ORDER BY server_name, database_name
    """,
    cypher_visual_query="""
    MATCH p=(server:AzureSQLServer)-[:RESOURCE]->(db:AzureSQLDatabase)
    WHERE server.public_network_access = 'Enabled'
    OR EXISTS {
        MATCH (server)-[:FIREWALL_RULE]->(rule:AzureFirewallRule)
        WHERE rule.start_ip_address = '0.0.0.0' AND rule.end_ip_address = '255.255.255.255'
    }
    OPTIONAL MATCH p2=(server)-[:FIREWALL_RULE]->(rule:AzureFirewallRule)
    RETURN *
    """,
    module=Module.AZURE,
)

# GCP
_gcp_compute_instance_internet_exposed = Fact(
    id="gcp_compute_instance_internet_exposed",
    name="Internet-Exposed GCP Compute Instances",
    description="GCP Compute Engine instances that are exposed to the internet through firewall rules",
    cypher_query="""
    MATCH (p:GCPProject)-[:RESOURCE]->(instance:GCPInstance)
    WHERE instance.exposed_internet = true
    RETURN p.name AS project_name,
        p.projectnumber AS project_number,
        instance.instancename AS instance_name,
        instance.zone_name AS zone,
        instance.status AS status
    ORDER BY project_name, instance_name
    """,
    cypher_visual_query="""
    MATCH p1=(proj:GCPProject)-[:RESOURCE]->(instance:GCPInstance)
    WHERE instance.exposed_internet = true
    OPTIONAL MATCH p2=(instance)-[:MEMBER_OF_GCP_FIREWALL]->(fw:GCPFirewall)
    OPTIONAL MATCH p3=(fw)-[:FIREWALL_INGRESS_RULE]->(rule:IpRule)
    RETURN *
    """,
    module=Module.GCP,
)

_gcp_storage_bucket_public = Fact(
    id="gcp_storage_bucket_public",
    name="Public GCP Storage Buckets",
    description="GCP Storage buckets with IAM policies that allow public access",
    cypher_query="""
    MATCH (p:GCPProject)-[:RESOURCE]->(bucket:GCPBucket)-[:POLICY]->(policy:GCPPolicy)
    WHERE ANY(binding IN policy.bindings WHERE
        'allUsers' IN binding.members OR 'allAuthenticatedUsers' IN binding.members)
    RETURN p.name AS project_name,
        bucket.id AS bucket_name,
        bucket.location AS location,
        bucket.storage_class AS storage_class
    ORDER BY project_name, bucket_name
    """,
    cypher_visual_query="""
    MATCH p1=(proj:GCPProject)-[:RESOURCE]->(bucket:GCPBucket)-[:POLICY]->(policy:GCPPolicy)
    WHERE ANY(binding IN policy.bindings WHERE
        'allUsers' IN binding.members OR 'allAuthenticatedUsers' IN binding.members)
    RETURN *
    """,
    module=Module.GCP,
)

_gcp_dns_zone_public = Fact(
    id="gcp_dns_zone_public",
    name="Public GCP DNS Zones",
    description="GCP DNS zones that are publicly visible and could expose internal infrastructure information",
    cypher_query="""
    MATCH (p:GCPProject)-[:RESOURCE]->(zone:GCPDNSZone)
    WHERE zone.visibility = 'public'
    RETURN p.name AS project_name,
        zone.name AS zone_name,
        zone.dns_name AS dns_name,
        zone.visibility AS visibility
    ORDER BY project_name, zone_name
    """,
    cypher_visual_query="""
    MATCH p=(proj:GCPProject)-[:RESOURCE]->(zone:GCPDNSZone)
    WHERE zone.visibility = 'public'
    RETURN *
    """,
    module=Module.GCP,
)

t1190 = Requirement(
    id="t1190",
    name="Exploit Public-Facing Application",
    description="Adversaries may attempt to take advantage of a weakness in an Internet-facing computer or program using software, data, or commands in order to cause unintended or unanticipated behavior.",
    facts=(
        # AWS
        _aws_ec2_instance_internet_exposed,
        _aws_s3_public,
        _aws_rds_public_access,
        _aws_load_balancer_internet_facing,
        _aws_load_balancer_v2_internet_facing,
        _aws_elasticsearch_public_access,
        _aws_lambda_anonymous_access,
        _aws_api_gateway_anonymous_access,
        _aws_eks_public_endpoint,
        # Azure
        _azure_storage_public_blob_access,
        _azure_sql_database_public,
        # GCP
        _gcp_compute_instance_internet_exposed,
        _gcp_storage_bucket_public,
        _gcp_dns_zone_public,
    ),
    requirement_url="https://attack.mitre.org/techniques/T1190/",
    # TODO: should we have a per-framework class represent the attributes?
    attributes={
        "tactic": "initial_access",
        "technique_id": "T1190",
        "services": [
            "ec2", "s3", "rds", "elb", "elasticsearch", "lambda", "apigateway", "eks",
            "azure_storage", "azure_sql",
            "gcp_compute", "gcp_storage", "gcp_dns"
        ],
        "providers": ["AWS", "AZURE", "GCP"],
    },
)
