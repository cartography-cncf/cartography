## SBOM Configuration

The SBOM module ingests [CycloneDX](https://cyclonedx.org/) SBOMs (typically generated by [Syft](https://github.com/anchore/syft)) and enriches existing TrivyPackage nodes with dependency graph information. This enables tracing from a CVE on a transitive dependency back to the direct dependency that needs to be updated.

## Why Trivy + Syft Together?

Cartography uses **Trivy for vulnerability detection** and **Syft for dependency graph construction**. This is intentional and provides the best of both worlds.

### Why not just generate an SBOM and pass it to Trivy?

A common misconception is that vulnerability scanning is simply "SBOM + CVE database lookup". In reality, Trivy's native scan provides significantly more accurate results because it operates on the actual artifact, not a flattened representation.

**Trivy's native scan has access to context that SBOMs cannot capture:**

| Capability | Native Trivy Scan | SBOM-based Scan |
|------------|-------------------|-----------------|
| Distro-specific CVE matching | Yes - reads `/etc/os-release`, package DB | Limited - must infer from SBOM metadata |
| Vendor backport detection | Yes - checks distro security trackers | No - version-only matching |
| Installation method context | Yes - knows static vs dynamic linking | No - only sees package exists |
| File-level heuristics | Yes - inspects binaries, JARs, wheels | No - cannot re-analyze files |
| Source package mapping | Yes - Debian/Ubuntu source relationships | Often missing from SBOMs |

**Concrete example**: A Debian package `openssl 1.1.1n-0+deb11u5` may have a CVE that was backported and fixed, but the version number didn't change. Trivy's native scan checks the Debian security tracker and knows this. An SBOM-based scan only sees "openssl 1.1.1n" and may incorrectly flag it as vulnerable.

### What Syft provides that Trivy doesn't

While Trivy excels at vulnerability detection, it does not construct a dependency graph. Syft's CycloneDX output includes:

- **Direct vs transitive dependency classification** via the `dependencies` array
- **Complete dependency tree** showing which packages depend on which
- **PURL (Package URL)** identifiers for cross-ecosystem compatibility

### The combined approach

```
┌─────────────────────────────────────────────────────────────────────┐
│  Step 1: Trivy Native Scan                                          │
│  trivy image IMAGE --format json                                    │
│  Creates: TrivyPackage nodes + TrivyImageFinding (CVE) nodes        │
│  Provides: Accurate, distro-aware vulnerability detection           │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  Step 2: Syft SBOM Generation                                       │
│  syft IMAGE -o cyclonedx-json                                       │
│  Creates: CycloneDX SBOM with dependency graph                      │
│  Provides: DEPENDS_ON relationships + is_direct property            │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  Step 3: Cartography Graph Merge                                    │
│  SBOM module enriches existing TrivyPackage nodes                   │
│  Result: CVEs + dependency graph in unified graph                   │
└─────────────────────────────────────────────────────────────────────┘
```

This enables queries like: "Given a CVE on a transitive dependency, which direct dependency should I update?"

## Prerequisites

Before using the SBOM module:

1. **Run Trivy ingestion first** - The SBOM module enriches existing TrivyPackage nodes. If no TrivyPackage nodes exist, the SBOM module has nothing to enrich.

2. **Generate Syft SBOMs** - Run Syft on your container images to produce CycloneDX JSON files.

## Usage

### Step 1: Ingest Trivy scan results

```bash
# Scan images with Trivy
trivy image myregistry/myimage:tag --format json --list-all-pkgs -o trivy-scan.json

# Ingest into Cartography
cartography --selected-modules trivy --trivy-results-dir /path/to/trivy-results
```

### Step 2: Generate Syft SBOMs

```bash
# Generate CycloneDX SBOM with Syft
syft myregistry/myimage:tag -o cyclonedx-json=sbom.json
```

**Important Syft parameters:**

- `-o cyclonedx-json` - Output format must be CycloneDX JSON
- The image must match the one scanned by Trivy

### Step 3: Ingest SBOM files

**From local directory:**

```bash
cartography --selected-modules sbom --sbom-results-dir /path/to/sbom-files
```

**From S3:**

```bash
cartography --selected-modules sbom --sbom-s3-bucket my-bucket --sbom-s3-prefix sbom-files/
```

### Combined workflow

For a complete workflow, run Trivy first, then SBOM:

```bash
# First: Trivy for vulnerabilities
cartography --selected-modules trivy --trivy-results-dir /path/to/trivy-results

# Then: SBOM for dependency graph
cartography --selected-modules sbom --sbom-results-dir /path/to/sbom-files
```

## Configuration Options

| Parameter | Description |
|-----------|-------------|
| `--sbom-results-dir` | Local directory containing CycloneDX JSON files |
| `--sbom-s3-bucket` | S3 bucket containing SBOM files |
| `--sbom-s3-prefix` | S3 prefix for SBOM files (optional, defaults to empty string) |

## Example Queries

### Find CVEs on direct dependencies

```cypher
MATCH (cve:TrivyImageFinding)-[:AFFECTS]->(pkg:TrivyPackage)
WHERE pkg.is_direct = true
RETURN cve.cve_id, cve.Severity, pkg.name, pkg.version
ORDER BY cve.Severity DESC
```

### Find which direct dependency to update for a transitive CVE

```cypher
MATCH (cve:TrivyImageFinding)-[:AFFECTS]->(vuln:TrivyPackage)
WHERE vuln.is_direct = false
MATCH path = (direct:TrivyPackage)-[:DEPENDS_ON*1..5]->(vuln)
WHERE direct.is_direct = true
RETURN cve.cve_id AS cve,
       cve.Severity AS severity,
       vuln.name AS vulnerable_package,
       direct.name AS update_this,
       [n in nodes(path) | n.name] AS dependency_chain
ORDER BY cve.Severity DESC
```

### List all direct dependencies with their transitive dependency count

```cypher
MATCH (direct:TrivyPackage)
WHERE direct.is_direct = true
OPTIONAL MATCH (direct)-[:DEPENDS_ON*1..10]->(transitive:TrivyPackage)
RETURN direct.name, count(DISTINCT transitive) AS transitive_count
ORDER BY transitive_count DESC
```
